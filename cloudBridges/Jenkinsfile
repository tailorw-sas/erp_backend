pipeline {
    
    agent any

    environment {
        ORIGIN_BRANCH_NAME = "${env.GIT_BRANCH}"
        DOCKER_IMAGE_NAME = 'tailorw/erp-cloud-bridges:version'
        SRC = 'cloudBridges'
        GIT_PACKAGE_TOKEN = credentials("GithubPackageToken")
        DOCKER_CREDENTIALS = 'Tailorw-DockerCredentials'
        NAMESPACE = 'finamer'
        K3S_CREDENTIALS = 'KubernetesCredential-env'
        YAML = 'cloudbridges.yaml'
        DEPLOYMENT_NAME = 'cloudbridges'
        URL_DEV = credentials("URL-K3S-dev")
        URL_QA = credentials("URL-K3S-qa")
    }
    
    triggers {
        githubPush()
        //triggers {
        //    genericTrigger {
        //        genericVariables([
        //            [key: 'changed_files', value: '$.commits[*].["modified","added","removed"][*]', expressionType: 'JSONPath'],    
        //        ])
        //        //causeString: 'Triggered on $changed_files',
        //        //token: 'abc123',
        //        printContributedVariables: true,
        //        printPostContent: true,
        //        regexpFilterText: '$changed_files',
        //        //regexpFilterExpression: '\\s((.*"("${SRC}"/)[^"]+?".))'
        //        regexpFilterExpression('^"${SRC}"/.*')
        //    }
        //}
    }
    
    stages {
        stage ('Init') {
            steps {
                echo 'Initializing generic...'
                script {   
                    def branch = env.ORIGIN_BRANCH_NAME.replace('origin/', '')
                    env.BRANCH_NAME = branch

                    def dockerImage = env.DOCKER_IMAGE_NAME.replace('version', env.BRANCH_NAME)
                    env.DOCKER_IMAGE = dockerImage

                    def k3sCredentials = env.K3S_CREDENTIALS.replace('env', env.BRANCH_NAME)
                    env.SERVER_K3S_CREDENTIALS = k3sCredentials

                    if(env.BRANCH_NAME == 'dev'){
                        env.SERVER_K3S_URL = env.URL_DEV
                    }
                    if(env.BRANCH_NAME == 'qa'){
                        env.SERVER_K3S_URL = env.URL_QA
                    }
                }
            }
        }

        stage ('Checkout specific project....') {
            steps {
                echo 'Identifying project...'
                script {
                    // Define la ruta a la carpeta específica que deseas observar
                    def folderPath = env.SRC
                    
                    // Obtén la lista de archivos modificados en la construcción
                    def changes = sh(script: 'git diff --name-only HEAD^ HEAD', returnStdout: true).trim().split('\n')

                    // Filtra los cambios para la carpeta específica
                    def changesInFolder = changes.findAll { it.startsWith(folderPath) }

                    if (changesInFolder) {
                        echo "Changes detected in folder: ${folderPath}"
                        // Realiza las acciones necesarias si hay cambios
                    } else {
                        echo "No changes detected in folder: ${folderPath}"
                        currentBuild.result = 'ABORTED'
                    }
                }
            }
        }
        
        stage ('Create docker image'){
            steps {
                dir("${SRC}"){
                    sh 'docker build -t $DOCKER_IMAGE --build-arg PACKAGE_TOKEN=$GIT_PACKAGE_TOKEN --build-arg POM_NAME=pom-$BRANCH_NAME.xml .'
                    withDockerRegistry(credentialsId: "${DOCKER_CREDENTIALS}", url: "") {
                        sh 'docker push $DOCKER_IMAGE'
                    }
                }
            }
        }

        stage ('Publish to Kubernetes') {
            steps {
                withKubeConfig(credentialsId: "${SERVER_K3S_CREDENTIALS}", namespace: "${NAMESPACE}", restrictKubeConfigAccess: false, serverUrl: "${SERVER_K3S_URL}") {
                    //sh 'kubectl apply -f kubernetes-config/deployments/$YAML'
                    sh 'kubectl rollout restart deploy $DEPLOYMENT_NAME'
                }
            }
        }
    }
}
