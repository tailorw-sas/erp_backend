@Library('emailNotification') _
import com.tailorw-sas.notificaciones.NotificadorEmail

pipeline {
    
    agent any

    parameters {
        booleanParam(name: 'FORCE_BUILD', defaultValue: false, description: 'Forzar la ejecuciÃ³n del pipeline sin verificar cambios')
    }

    environment {
        ORIGIN_BRANCH_NAME = "${env.GIT_BRANCH}"
        DOCKER_IMAGE_NAME = 'tailorw/erp-insis:version'
        SRC = 'insis'
        SRC_SHARE = 'share'
        GIT_PACKAGE_TOKEN = credentials("GithubPackageToken")
        DOCKER_CREDENTIALS = 'Tailorw-DockerCredentials'
        NAMESPACE = 'finamer'
        K3S_CREDENTIALS = 'KubernetesCredential-env'
        YAML = 'insis.yaml'
        DEPLOYMENT_NAME = 'insis'
        URL_DEV = credentials("URL-K3S-dev")
        URL_QA = credentials("URL-K3S-qa")
        EMAIL_FROM = "${env.CORREO_ORIGEN}"
        PR_ID = "${env.CHANGE_ID}"
    }
    
    triggers {
        githubPush()
    }
    
    stages {

        stage ('Check for changes') {
            steps {
                echo '* * * * STAGE: Checking for changes in a specific project * * * *'
                script {
                    echo "**El ID del Pull Request es: ${PR_ID}"
                    if (!params.FORCE_BUILD){
                        def folderPaths = [env.SRC, env.SRC_SHARE]
                        def changes = sh(script: 'git diff --name-only HEAD^ HEAD', returnStdout: true).trim().split('\n')
                        def changesInFolder = changes.findAll { item -> folderPaths.any { palabra -> item.toLowerCase().contains(palabra.toLowerCase()) } }
                        if (changesInFolder) {
                            echo "Changes detected in folders: ${SRC} y/o ${SRC_SHARE}"
                        } else {
                            echo "* * * * * * * * No changes detected in folders: ${SRC} y/o ${SRC_SHARE} * * * * * * * *"
                            currentBuild.result = 'NOT_BUILT'
                            error('No changes detected in folders: $SRC y/o $SRC_SHARE' )
                        }
                    }
                }
            }
        }
        
        stage ('Initialize variables') {
            steps {
                echo '* * * * STAGE: Initializing variables * * * *'
                script {   
                    def branch = env.ORIGIN_BRANCH_NAME.replace('origin/', '')
                    env.BRANCH_NAME = branch

                    def dockerImage = env.DOCKER_IMAGE_NAME.replace('version', env.BRANCH_NAME)
                    env.DOCKER_IMAGE = dockerImage

                    def k3sCredentials = env.K3S_CREDENTIALS.replace('env', env.BRANCH_NAME)
                    env.SERVER_K3S_CREDENTIALS = k3sCredentials

                    if(env.BRANCH_NAME == 'dev'){
                        env.SERVER_K3S_URL = env.URL_DEV
                        env.EMAIL_LIST = env.EMAIL_LIST_DEV
                    }
                    if(env.BRANCH_NAME == 'qa'){
                        env.SERVER_K3S_URL = env.URL_QA
                        env.EMAIL_LIST = env.EMAIL_LIST_QA
                    }
                }
            }
        }

        stage ('Create docker image'){
            steps {
                echo '* * * * STAGE: Creating docker image * * * *'
                dir("${SRC}"){
                    sh 'docker build --no-cache -t $DOCKER_IMAGE --build-arg PACKAGE_TOKEN=$GIT_PACKAGE_TOKEN --build-arg POM_NAME=pom-$BRANCH_NAME.xml .'
                    withDockerRegistry(credentialsId: "${DOCKER_CREDENTIALS}", url: "") {
                        sh 'docker push $DOCKER_IMAGE'
                    }
                }
            }
        }

        stage ('Publish to Kubernetes') {
            steps {
                echo '* * * * STAGE: Publishing to kubernetes * * * *'
                withKubeConfig(credentialsId: "${SERVER_K3S_CREDENTIALS}", namespace: "${NAMESPACE}", restrictKubeConfigAccess: false, serverUrl: "${SERVER_K3S_URL}") {
                    //sh 'kubectl apply -f kubernetes-config/deployments/$YAML'
                    sh 'kubectl rollout restart deploy $DEPLOYMENT_NAME'
                }
            }
        }
    }

    post {
        success {
            def notificator = new NotificadorEmail()
            def body = """<h2><strong>Build Successful!!!!</strong></h2>
                        <p>Job: ${env.JOB_NAME} [${env.BUILD_NUMBER}]</p>
                        <p>Branch: ${env.BRANCH_NAME}</p>"""
            notificator.enviarEmail("${EMAIL_LIST}", "DEVOPS - TAILORW - FAILURE: Job '${env.JOB_NAME}' (${env.BRANCH_NAME})", body, "${EMAIL_FROM}")
        }
        failure {
            emailext(
                subject: "DEVOPS - TAILORW - FAILURE: Job '${env.JOB_NAME}' (${env.BRANCH_NAME})",
                body: """<h2><strong>Build Failed!</strong></h2>
                        <p>Job: ${env.JOB_NAME} [${env.BUILD_NUMBER}]</p>
                        <p>Branch: ${env.BRANCH_NAME}</p>""",
                to: "${EMAIL_LIST}",
                from: "${EMAIL_FROM}"
            )
        }
    }
}
